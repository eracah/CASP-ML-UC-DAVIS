__author__ = 'Evan Racah'

from sklearn import metrics

import pickle
import numpy as np
from HelperFunctions import concatenate_arrays


class TrainingSampleResult(object):
    """Class that acts sort of like a struct for each estimator/training size combo
    It contains any piece of data that might be relevant for plotting or looking at
    It takes in the already-fitted grid_search object for a specific estimator and training size
    (containing the optimal estimator)
    And calculates and stores:
        -the error for each tried parameter
        -the set of all parameters used in optimal estimator (as a dict; key: parameter name, value: parameter value)
        -predicted values for test and train (generated by the predict function on the estimator)
        -actual values for test and train
        -prediction errors (MSE) for test and training data
        -the time to do the grid search for the grid search object
        """
    #TODO: add in more time metrics to this class
    def __init__(self, trials_per_size, test_data):
        self.data_dict = {  'best_parameter_values': [],
                            'error_parameter_values': [],
                            'test_predicted_values': [],
                            'test_actual_values': [],
                            'test_prediction_error': [],
                            #'train_predicted_values': [],
                            'train_prediction_error': []}

        self.x_test, self.y_test = test_data
        self.grid_search_objects = []
        self.x_trains = []
        self.y_trains = []
        self.times_to_fit = []
        self.trials = trials_per_size
        self.count = 0


    def add_sample_results(self, grid_search_object, train_data, time_to_fit):
        self.grid_search_objects.append(grid_search_object)
        x_train, y_train = train_data
        self.x_trains.append(x_train)
        self.y_trains.append(y_train)
        self.times_to_fit.append(time_to_fit)
        self.count += 1
        if self.count == self.trials:
            self._get_performance_of_data()
            self._calc_average_of_runs()


    def _get_performance_of_data(self):

        #just pull one trial for best parameter values and error parameter value
        #because hard to average these ones
        self.data_dict['best_parameter_values'].append(self.grid_search_objects[0].best_estimator_.get_params())
        self.data_dict['error_parameter_values'].append(self.grid_search_objects[0].grid_scores_)

        self.data_dict['time_to_fit'] = self.times_to_fit
        #self.data_dict['train_actual_values'] = self.y_trains
        for index, grid in enumerate(self.grid_search_objects):

            self.data_dict['test_predicted_values'].append(grid.best_estimator_.predict(self.x_test))
            self.data_dict['test_actual_values'].append(self.y_test)
            self.data_dict['test_prediction_error'].append(metrics.mean_squared_error(
                                                    self.data_dict['test_predicted_values'][index],
                                                    self.data_dict['test_actual_values'][index]))
            #self.data_dict['train_predicted_values'].append(grid.best_estimator_.predict(self.x_trains[index]))
            self.data_dict['train_prediction_error'].append(metrics.mean_squared_error(
                                                            grid.best_estimator_.predict(self.x_trains[index]),
                                                            self.y_trains[index]))

        #turn any lists of numpy arrays into a matrix with each row as one of the arrays
        for key in ('test_predicted_values', 'test_actual_values'):
            self.data_dict[key] = concatenate_arrays(range(self.trials), [self.data_dict[key]])



    def _calc_average_of_runs(self):
        for key in self.data_dict.keys():
            if not (key =='best_parameter_values' or key =='error_parameter_values'):
                self.data_dict[key] = np.mean(self.data_dict[key], axis=0)


class EstimatorResult(object):
    """Estimator Results Class:
    Contains a dictionary with a TrainingSampleResult object for each Training Size
    Contains getter methods for a single instance of the TrainingSampleResult class
    Also contains getter methods for getting data from all TrainingSampleResult objects in
    the training sample dict"""

    def __init__(self, estimator_name):
        self.name = estimator_name
        self.training_sample_dict = {}

    def add_training_results(self, training_size, grid_search_object, test_data, train_data, time_to_fit, trial,
                             trials_per_size):
        #create
        if trial == 0:
            self.training_sample_dict[training_size] = TrainingSampleResult(trials_per_size, test_data)

        self.training_sample_dict[training_size].add_sample_results(grid_search_object, train_data,
                                                                    time_to_fit)


    def get_data(self, data_name, sizes):
        return [obj.data_dict[data_name] for obj in [self.training_sample_dict[size] for size in sizes]]

    def get_plot_arrays(self, sizes, names):
        ret = len(names)*[0]
        for i, name in enumerate(names):
            if name == 'training_size':
                ret[i] = sizes
            else:
                ret[i] = self.get_data(name, sizes)

        return ret





class MainResult(object):
    """Main results class:
    Contains a dictionary, which contains an EstimatorResults object for each estimator
    Also has method for plotting all estimators against each other in a learning curve"""

    def __init__(self, estimator_names, path_to_store_results, file_name):
        """

        :type self: object
        """
        self.estimator_dict = {}
        self.estimator_names = estimator_names

        #add an estimatorResult object for each estimator to the dictionary
        for name in self.estimator_names:
            #make a new key value pair, where key is the estimator and value is an EstimatorResult object
            self.estimator_dict[name] = EstimatorResult(name)

        self.filename = file_name
        self.path = path_to_store_results


    def add_estimator_results(self, estimator_name, training_size, grid_search_object, test_data, train_data,
                              time_to_fit, trial, trials_per_size):
        # adds training results to the EstimatorResult object for the corresponding correct estimator_name
        self.estimator_dict[estimator_name].add_training_results(training_size,
                                                                 grid_search_object,
                                                                 test_data,
                                                                 train_data,
                                                                 time_to_fit, trial, trials_per_size)

    #TODO: Move this outside of this class
    def save_data(self):
        with open(self.path + self.filename, 'wb') as f:
            pickle.dump(self, f)













