__author__ = 'Evan Racah'

from sklearn import metrics
from matplotlib import pyplot as plt
import time
import pickle
import numpy as np
from HelperFunctions import concatenate_arrays



class TrainingSampleResult(object):
    """Class that acts sort of like a struct for each estimator/training size combo
    It contains any piece of data that might be relevant for plotting or looking at
    It takes in the already-fitted grid_search object for a specific estimator and training size
    (containing the optimal estimator)
    And calculates and stores:
        -the error for each tried parameter
        -the set of all parameters used in optimal estimator (as a dict; key: parameter name, value: parameter value)
        -predicted values for test and train (generated by the predict function on the estimator)
        -actual values for test and train
        -prediction errors (MSE) for test and training data
        -the time to do the grid search for the grid search object
        """
    #TODO: add in more time metrics to this class
    def __init__(self, trials_per_size):
        self.trials = trials_per_size
        self.count = 0
        self.best_parameter_values = trials_per_size * [0]
        #gets cross validation error for each parameter value tried (as a tuple
        self.error_parameter_values = trials_per_size*[0]
        self.test_predicted_values = trials_per_size * [0]
        self.test_actual_values = trials_per_size * [0]
        self.train_predicted_values = trials_per_size * [0]
        self.train_actual_values = trials_per_size * [0]
        self.test_prediction_error = trials_per_size * [0]
        self.train_prediction_error = trials_per_size * [0]
        self.time_to_fit = trials_per_size*[0]


    def add_sample_results(self, grid_search_object, test_data, train_data, time_to_fit):
        x_test, y_test = test_data
        x_train, y_train = train_data


        self.best_parameter_values[self.count] = grid_search_object.best_estimator_.get_params()

        #gets cross validation error for each parameter value tried (as a tuple
        self.error_parameter_values[self.count] = grid_search_object.grid_scores_
        self.test_predicted_values[self.count] = grid_search_object.best_estimator_.predict(x_test)
        self.test_actual_values[self.count] = y_test
        self.train_predicted_values[self.count] = grid_search_object.best_estimator_.predict(x_train)
        self.train_actual_values[self.count] = y_train
        self.test_prediction_error[self.count] = metrics.mean_squared_error(self.test_predicted_values[self.count],
                                                                            self.test_actual_values[self.count])
        self.train_prediction_error[self.count] = metrics.mean_squared_error(self.train_predicted_values[self.count],
                                                                             self.train_actual_values[self.count])
        self.time_to_fit[self.count] = time_to_fit
        self.count += 1
        if self.count == self.trials:
            self.test_predicted_values = self.get_mean(self.test_predicted_values)
            self.test_actual_values = self.get_mean(self.test_actual_values)
            #self.train_predicted_values = self.get_mean(self.train_predicted_values)
            #self.train_actual_values = self.get_mean(self.train_actual_values)
            self.test_prediction_error = self.get_mean(self.test_prediction_error)
            self.train_prediction_error = self.get_mean(self.train_prediction_error)


    def get_mean(self, python_list):
        array = np.asarray(python_list)
        print array.shape
        return np.mean(array, axis=0)


class EstimatorResult(object):
    """Estimator Results Class:
    Contains a dictionary with a TrainingSampleResult object for each Training Size
    Contains getter methods for a single instance of the TrainingSampleResult class
    Also contains getter methods for getting data from all TrainingSampleResult objects in
    the training sample dict"""

    def __init__(self, estimator_name):
        self.name = estimator_name
        self.training_sample_dict = {}

    def add_training_results(self, training_size, grid_search_object, test_data, train_data, time_to_fit, trial,
                             trials_per_size):

        if trial == 0:
            self.training_sample_dict[training_size] = TrainingSampleResult(trials_per_size)

        self.training_sample_dict[training_size].add_sample_results(grid_search_object, test_data, train_data,
                                                                  time_to_fit)

    def get_test_pred_error(self, train_sample_result):
        #this function is just to make the map function work
        return train_sample_result.test_prediction_error

    def get_train_pred_error(self, train_sample_result):
        #this function is just to make the map function work
        return train_sample_result.train_prediction_error

    def get_test_actuals(self, train_sample_result):
        #returns the labels (the answers)
        return train_sample_result.test_actual_values

    def get_test_predicted(self, train_sample_result):
        return train_sample_result.test_predicted_values

    def get_parameter_errors(self, train_sample_result):
        return train_sample_result.self.error_parameter_values


    def get_test_prediction_error_data(self):
        #returns two vectors: vec of all the training sizes and vec of all prediction errors
        return self.training_sample_dict.keys(), map(self.get_test_pred_error, self.training_sample_dict.values())

    def get_train_prediction_error_data(self):
        #returns two vectors: vec of all the training sizes and vec of all prediction errors
        return self.training_sample_dict.keys(), map(self.get_train_pred_error, self.training_sample_dict.values())

    def get_actuals_and_predictions_data(self):
        return self.training_sample_dict.keys(), map(self.get_test_actuals, self.training_sample_dict.values()), \
               map(self.get_test_predicted, self.training_sample_dict.values())


class MainResult(object):
    """Main results class:
    Contains a dictionary, which contains an EstimatorResults object for each estimator
    Also has method for plotting all estimators against each other in a learning curve"""

    def __init__(self, estimator_names, path_to_store_results, file_name):
        self.estimator_dict = {}
        self.estimator_names = estimator_names
        #add an estimatorResult object for each estimator to the dictionary
        for name in self.estimator_names:
            #make a new key value pair, where key is the estimator and value is an EstimatorResult object
            self.estimator_dict[name] = EstimatorResult(name)


        self.filename = file_name
        self.path = path_to_store_results


    def add_estimator_results(self, estimator_name, training_size, grid_search_object, test_data, train_data,
                              time_to_fit, trial, trials_per_size):
        # adds training results to the EstimatorResult object for the corresponding correct estimator_name
        self.estimator_dict[estimator_name].add_training_results(training_size,
                                                                 grid_search_object,
                                                                 test_data,
                                                                 train_data,
                                                                 time_to_fit, trial, trials_per_size)

    #TODO: Move this outside of this class
    def save_data(self):
        with open(self.path + self.filename, 'wb') as f:
            pickle.dump(self, f)













